<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>StruDoL - Structured Domain Language</title>
    
    <!-- Core CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css" rel="stylesheet">
    <link href="https://unpkg.com/@yaireo/tagify@4.17.8/dist/tagify.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/simplemde/latest/simplemde.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display&display=swap" rel="stylesheet">

    <style>
        body {
            overflow-x: hidden;
            background-color: var(--bs-body-bg);
        }
        
        #app-container {
            display: flex;
            min-height: 100vh;
        }
        
        #sidebar {
            position: fixed;
            height: 100vh;
            width: 380px;
            top: 0;
            left: 0;
            z-index: 1030;
            overflow-y: auto;
            background-color: var(--bs-body-bg);
            border-right: 1px solid var(--bs-border-color);
            transition: transform 0.3s ease;
        }
        
        #sidebar.collapsed {
            transform: translateX(-380px);
        }
        
        #main-content {
            flex: 1;
            transition: margin-left 0.3s;
            padding: 20px;
            margin-left: 380px;
            padding-top: 65px;
            max-width: calc(90vw - 380px);
            margin-right: auto;
        }
        
        @media (min-width: 1600px) {
            #main-content {
                max-width: 1200px;
            }
        }
        
        #main-content.expanded {
            margin-left: 0;
            max-width: 90vw;
        }
        
        .main-header {
            position: fixed;
            top: 0;
            left: 380px;
            right: 0;
            z-index: 1020;
            transition: left 0.3s ease;
            background-color: var(--bs-body-bg);
            border-bottom: 1px solid var(--bs-border-color);
        }
        
        .main-header.expanded {
            left: 0;
        }
        
        .item-container {
            margin-bottom: 1rem;
            border: 1px solid var(--bs-border-color-translucent);
            border-radius: var(--bs-border-radius);
            background-color: var(--bs-card-bg);
            scroll-margin-top: 70px;
            position: relative;
        }
        
        .item-header {
            padding: 0.65rem 1rem;
            background-color: var(--bs-tertiary-bg);
            border-bottom: 1px solid var(--bs-border-color-translucent);
            position: relative;
        }
        
        .item-title-area {
            display: flex;
            align-items: center;
            flex: 1;
            position: relative;
        }
        
        .item-title {
            margin-bottom: 0;
            font-weight: 500;
        }
        
        .item-content {
            padding: 0.75rem;
        }
        
        .item-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 0.25rem;
            margin-left: 0.5rem;
        }
        
        .item-tag {
            font-size: 0.7rem;
            padding: 0.15rem 0.35rem;
            border-radius: var(--bs-border-radius-sm);
            background-color: var(--bs-secondary-bg);
            color: var(--bs-secondary-color);
        }
        
        .item-children {
            margin-left: 1.5rem;
            margin-bottom: 1rem;
        }
        
        .item-actions {
            position: absolute;
            right: 16px;
            top: 50%;
            transform: translateY(-50%);
            opacity: 0;
            transition: opacity 0.2s ease;
            background-color: var(--bs-tertiary-bg);
            padding: 4px;
            border-radius: var(--bs-border-radius-sm);
            z-index: 100;
            display: flex;
        }
        
        .item-header:hover .item-actions {
            opacity: 1;
        }
        
        .action-btn {
            width: 28px;
            height: 28px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: transparent;
            border: none;
            border-radius: var(--bs-border-radius-sm);
            color: var(--bs-secondary-color);
        }
        
        .action-btn:hover {
            background-color: var(--bs-tertiary-bg);
        }
        
        .action-btn.add-btn {
            color: var(--bs-primary);
        }
        
        .doc-nav {
            list-style: none;
            padding-left: 0;
        }

        .doc-nav-item {
            margin-bottom: 0;
            line-height: 1.1;
        }
        
        .doc-nav-toggle {
            cursor: pointer;
            display: inline-block;
            width: 16px;
            text-align: center;
        }
        
        .doc-nav-indent {
            display: inline-block;
            width: 4px;
            color: var(--bs-secondary-color);
        }
        
        .doc-nav-link {
            display: inline-block;
            color: var(--bs-body-color);
            text-decoration: none;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            transition: all 0.2s;
            border-radius: var(--bs-border-radius-sm);
            max-width: 300px;
            font-size: 0.85rem;
        }

        .doc-nav-link:hover {
            background-color: var(--bs-tertiary-bg);
        }

        .doc-nav-link.active {
            background-color: var(--bs-primary);
            color: white;
        }
        
        .item-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 28px;
            height: 28px;
            margin-right: 10px;
            font-size: 1.1rem;
        }
        
        .list-priority .item-icon { color: var(--bs-danger); }
        .list-weight .item-icon { color: var(--bs-success); }
        .list-sequence .item-icon { color: var(--bs-primary); }
        .list-steps .item-icon { color: var(--bs-info); }
        .list-temporality .item-icon { color: var(--bs-purple); }
        .list-range .item-icon { color: var(--bs-orange); }
        .list-category .item-icon { color: var(--bs-warning); }
        
        .item-children .item-container:nth-child(1) .item-icon { opacity: 1; }
        .item-children .item-container:nth-child(2) .item-icon { opacity: 0.7; }
        .item-children .item-container:nth-child(3) .item-icon { opacity: 0.5; }
        .item-children .item-container:nth-child(n+4) .item-icon { opacity: 0.3; }

        #tag-filter-accordion .accordion-button.filtering {
            background-color: rgba(var(--bs-primary-rgb), 0.2);
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { background-color: rgba(var(--bs-tertiary-bg-rgb), 1); }
            50% { background-color: rgba(var(--bs-primary-rgb), 0.2); }
            100% { background-color: rgba(var(--bs-tertiary-bg-rgb), 1); }
        }

        .modal .CodeMirror {
            height: 200px;
        }
        
        .app-logo {
            font-size: 2rem; 
            font-weight: normal;
            font-family: 'Playfair Display', serif; 
            color: #4B0082;
        }

        .sortable-ghost {
            opacity: 0.4;
            background-color: var(--bs-tertiary-bg);
        }
        
        .sortable-chosen {
            background-color: var(--bs-secondary-bg);
        }
        
        .item-drag-handle {
            cursor: move;
        }
        
        .item-tag.special-tag {
            background-color: var(--bs-info-bg-subtle);
            color: var(--bs-info);
            border: 1px solid var(--bs-info-border-subtle);
        }
    </style>
</head>
<body>
    <nav id="main-header" class="main-header navbar navbar-expand-lg navbar-light py-2 px-3">
        <div class="container-fluid">
            <div class="d-flex align-items-center">
                <button id="expand-sidebar-btn" class="btn btn-sm me-2 d-none" title="Show sidebar">
                    <i class="bi bi-layout-sidebar-inset"></i>
                </button>
                <span id="document-title" class="h5 mb-0" tabindex="-1">Untitled Document</span>
            </div>
            <div class="d-flex gap-2 align-items-center">
                <button id="chat-open-btn" class="btn btn-outline-primary btn-sm">
                    <i class="bi bi-chat-dots me-1"></i> AI Assistant
                </button>
                <div class="dropdown">
                    <button class="btn btn-outline-primary btn-sm dropdown-toggle" type="button" id="export-dropdown" data-bs-toggle="dropdown" aria-expanded="false">
                        <i class="bi bi-download me-1"></i> Export/Import
                    </button>
                    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="export-dropdown">
                        <li><a class="dropdown-item" id="export-json-btn" href="#"><i class="bi bi-filetype-json me-2"></i>Export as JSON</a></li>
                        <li><a class="dropdown-item" id="export-md-btn" href="#"><i class="bi bi-filetype-md me-2"></i>Export as Markdown</a></li>
                        <li><a class="dropdown-item" id="export-html-btn" href="#"><i class="bi bi-filetype-html me-2"></i>Export as HTML</a></li>
                        <li><a class="dropdown-item" id="export-docx-btn" href="#"><i class="bi bi-file-earmark-word me-2"></i>Export as DOCX</a></li>
                        <li><a class="dropdown-item" id="export-csv-btn" href="#"><i class="bi bi-filetype-csv me-2"></i>Export as CSV</a></li>
                        <li><hr class="dropdown-divider"></li>
                        <li><a class="dropdown-item" id="import-json-btn" href="#"><i class="bi bi-upload me-2"></i>Import JSON</a></li>
                    </ul>
                </div>
                <button id="import-btn" class="btn btn-outline-secondary btn-sm">
                    <i class="bi bi-upload me-1"></i> Import
                </button>
                <button id="clear-btn" class="btn btn-outline-danger btn-sm">
                    <i class="bi bi-trash me-1"></i> Clear
                </button>
            </div>
        </div>
    </nav>

    <div id="app-container">
        <div id="sidebar" class="p-3">
            <div class="d-flex justify-content-between align-items-center mb-4">
                <h5 class="app-logo" id="sidebarLabel">StruDoL</h5>
                <button type="button" class="btn-close" id="collapse-sidebar-btn" aria-label="Close"></button>
            </div>
            <div class="sidebar-content p-0">
                <div class="accordion mb-3" id="tag-filter-accordion">
                    <div class="accordion-item">
                        <h2 class="accordion-header">
                            <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#tag-filter-collapse" id="tag-filter-btn">
                                <i class="bi bi-tags me-2"></i> Filter by Tags
                            </button>
                        </h2>
                        <div id="tag-filter-collapse" class="accordion-collapse collapse show" data-bs-parent="#tag-filter-accordion">
                            <div class="accordion-body">
                                <div id="tag-filters" class="d-flex flex-wrap gap-1 mb-2"></div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="mb-3">
                    <h6 class="fs-6 mb-2">Document Navigation</h6>
                    <div id="document-navigation" class="doc-nav"></div>
                </div>
                
                <div class="text-center mt-4">
                    <button 
                        id="add-top-item-btn" 
                        class="btn btn-outline-primary"
                    >
                        <i class="bi bi-plus-circle me-2"></i> Add Item
                    </button>
                </div>
            </div>
        </div>
        
        <div id="main-content">
            <div id="welcome-screen">
                <div class="text-center py-5">
                    <h1 class="display-5 mb-3">Welcome to StruDoL</h1>
                    <p class="lead mb-5">Create, organize, and structure your domain knowledge</p>
                    
                    <div class="dropzone border border-2 border-dashed p-5 rounded mb-4 bg-body-tertiary" id="file-dropzone">
                        <i class="bi bi-cloud-upload display-4 mb-2"></i>
                        <p>Drag and drop your JSON file here or click to select</p>
                        <button class="btn btn-outline-primary mt-2">Select File</button>
                    </div>
                    <input type="file" id="file-input" accept=".json" class="d-none">
                    
                    <button id="create-new-btn" class="btn btn-primary">Create New Document</button>
                </div>
            </div>
            
            <div id="document-content" class="d-none"></div>
        </div>
    </div>
    
    <div class="offcanvas offcanvas-end" tabindex="-1" id="chatbot-panel" aria-labelledby="chatbotPanelLabel">
        <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="chatbotPanelLabel">AI Assistant</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" id="close-chatbot-btn" aria-label="Close"></button>
        </div>
        <div class="offcanvas-body">
            <div id="chat-context-info" class="mb-3">
                <p class="mb-1 fw-bold">Current section: <span id="current-item-title">None selected</span></p>
            </div>
            <div id="chat-messages" class="border rounded p-3 mb-3 overflow-auto" style="height: 300px;">
            </div>
            <div id="chat-input-container">
                <div class="input-group mb-3">
                    <input type="text" id="chat-input" class="form-control" placeholder="Type your question...">
                    <button id="chat-send-btn" class="btn btn-primary">
                        <i class="bi bi-send"></i>
                    </button>
                </div>
            </div>
            <div id="chat-loading" class="d-none">
                <div class="d-flex justify-content-center align-items-center">
                    <div class="spinner-border text-primary spinner-border-sm me-2" role="status">
                        <span class="visually-hidden">Loading...</span>
                    </div>
                    <span>This might take a moment...</span>
                </div>
            </div>
            <div id="suggested-items" class="mt-4">
                <h5>Add sub-items</h5>
                <div id="suggested-items-list">
                    <div class="alert alert-info">No suggested items available yet.</div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="offcanvas offcanvas-end" tabindex="-1" id="info-panel" aria-labelledby="infoPanelLabel">
        <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="info-panel-title">Information</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" id="close-info-btn" aria-label="Close"></button>
        </div>
        <div class="offcanvas-body">
            <div id="related-items" class="related-items d-none">
                <h5>Related Items</h5>
                <div id="related-items-list"></div>
            </div>
            <div id="info-panel-content"></div>
        </div>
    </div>
    
    <div class="modal fade" id="item-editor-modal" tabindex="-1" aria-hidden="true">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="item-editor-title">Edit Item</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <form id="item-editor-form">
                        <div class="mb-3">
                            <label for="item-title" class="form-label">Title</label>
                            <input type="text" class="form-control" id="item-title" required>
                        </div>
                        <div class="mb-3">
                            <label for="item-tags" class="form-label">Tags</label>
                            <input type="text" class="form-control" id="item-tags">
                            <div class="form-text mt-1">
                                Use comma-separated tags. Special tag format: <code>type:value</code> is used for items classification.
                            </div>
                        </div>
                        <div class="mb-3">
                            <div class="form-text mt-2">
                                To specify a list type, add a tag with format <code>type:priority</code>, <code>type:weight</code>, <code>type:sequence</code>, etc.
                            </div>
                        </div>
                        <div class="mb-3">
                            <label for="item-content" class="form-label">Content</label>
                            <textarea class="form-control" id="item-content" rows="5"></textarea>
                        </div>
                        <input type="hidden" id="item-id">
                        <input type="hidden" id="parent-id">
                    </form>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-danger me-auto" id="delete-item-btn">Delete</button>
                    <button type="button" class="btn btn-primary" id="save-item-btn">Save Changes</button>
                </div>
            </div>
        </div>
    </div>
    
    <div class="modal fade" id="delete-confirm-modal" tabindex="-1" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Confirm Deletion</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <p>Are you sure you want to delete this item? This will also delete all child items.</p>
                    <p class="text-danger"><strong>This action cannot be undone.</strong></p>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-danger" id="confirm-delete-btn">Delete</button>
                </div>
            </div>
        </div>
    </div>
    
    <div class="modal fade" id="clear-confirm-modal" tabindex="-1" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Confirm Clear</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <p>Are you sure you want to clear the current document? This will remove all items.</p>
                    <p class="text-danger"><strong>This action cannot be undone.</strong></p>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-danger" id="confirm-clear-btn">Clear Document</button>
                </div>
            </div>
        </div>
    </div>
    
    <div class="toast-container position-fixed top-0 end-0 p-3" id="toast-container">
    </div>
    
    <!-- Core libraries -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone@7.23.2/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
    <script src="https://unpkg.com/@yaireo/tagify@4.17.8/dist/tagify.min.js"></script>
    <script src="https://cdn.jsdelivr.net/simplemde/latest/simplemde.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.6/dist/purify.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/uuid@9.0.1/dist/umd/uuidv4.min.js"></script>
    
    <!-- Export libraries -->
    <script src="https://cdn.jsdelivr.net/npm/file-saver/dist/FileSaver.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/json2md@2.0.0/dist/json2md.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/docx@8.0.4/build/index.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
    
    <script>
        // Add UUID library implementation
        !function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):(t="undefined"!=typeof globalThis?globalThis:t||self).uuidv4=e()}(this,(function(){"use strict";var t="undefined"!=typeof crypto&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto)||"undefined"!=typeof msCrypto&&"function"==typeof msCrypto.getRandomValues&&msCrypto.getRandomValues.bind(msCrypto),e=new Uint8Array(16);function o(){if(!t)throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return t(e)}var n=/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;function r(t){return"string"==typeof t&&n.test(t)}for(var i=[],f=0;f<256;++f)i.push((f+256).toString(16).substr(1));return function(t,e,n){var f=(t=t||{}).random||(t.rng||o)();if(f[6]=15&f[6]|64,f[8]=63&f[8]|128,e){n=n||0;for(var u=0;u<16;++u)e[n+u]=f[u];return e}return function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,o=(i[t[e+0]]+i[t[e+1]]+i[t[e+2]]+i[t[e+3]]+"-"+i[t[e+4]]+i[t[e+5]]+"-"+i[t[e+6]]+i[t[e+7]]+"-"+i[t[e+8]]+i[t[e+9]]+"-"+i[t[e+10]]+i[t[e+11]]+i[t[e+12]]+i[t[e+13]]+i[t[e+14]]+i[t[e+15]]).toLowerCase();if(!r(o))throw TypeError("Stringified UUID is invalid");return o}(f)}}));
    </script>

    <script type="text/babel" data-presets="react">
    // Constants
    const WEBHOOK_URL = "https://n8n.lucascervera.com/webhook/strubasechatbot";
    const LOCAL_STORAGE_KEY = 'strudol-data';
    const LIST_TYPES = {
        priority: { icon: 'bi-bullseye', color: 'danger' },
        weight: { icon: 'bi-shield', color: 'success' },
        sequence: { icon: 'bi-collection', color: 'primary' },
        steps: { icon: 'bi-diagram-3', color: 'info' },
        temporality: { icon: 'bi-calendar-event', color: 'purple' },
        range: { icon: 'bi-graph-up-arrow', color: 'orange' },
        category: { icon: 'bi-folder', color: 'warning' }
    };

    // Bootstrap components initialization
    const root = ReactDOM.createRoot(document.getElementById('document-content'));
    const chatbotPanel = new bootstrap.Offcanvas(document.getElementById('chatbot-panel'));
    const infoPanel = new bootstrap.Offcanvas(document.getElementById('info-panel'));

    /**
     * Utility functions for the application
     */
    const Utils = {
// ID generation - always use UUID or fallback to random string
generateItemId() {
    // Check if uuidv4 is available
    if (typeof uuidv4 !== 'undefined') {
        return uuidv4();
    } else {
        // Fallback implementation for UUID
        return 'id-' + Math.random().toString(36).substring(2, 15) + 
               Math.random().toString(36).substring(2, 15);
    }
},
        
        // Extract type from tags
        getTypeFromTags(tags) {
            if (!tags) return '';
            const tagsList = tags.split(',').map(tag => tag.trim());
            const typeTag = tagsList.find(tag => tag.startsWith('type:'));
            return typeTag ? typeTag.split(':')[1] : '';
        },
        
        // Get icon for list type
        getListTypeIcon(type) {
            return LIST_TYPES[type]?.icon || 'bi-circle';
        },
        
        // Show alert toast
        showAlert(message, type = 'success', duration = 3000) {
            const toastId = `toast-${Date.now()}`;
            const toastHtml = `
                <div id="${toastId}" class="toast" role="alert" aria-live="assertive" aria-atomic="true">
                    <div class="toast-header">
                        <span class="bg-${type} rounded me-2" style="width:16px; height:16px;"></span>
                        <strong class="me-auto">StruDoL</strong>
                        <button type="button" class="btn-close" data-bs-dismiss="toast" aria-label="Close"></button>
                    </div>
                    <div class="toast-body">
                        ${message}
                    </div>
                </div>
            `;
            
            const toastContainer = document.getElementById('toast-container');
            toastContainer.insertAdjacentHTML('beforeend', toastHtml);
            const toastElement = document.getElementById(toastId);
            const toast = new bootstrap.Toast(toastElement, { 
                autohide: true, 
                delay: duration 
            });
            
            toast.show();
            
            toastElement.addEventListener('hidden.bs.toast', () => {
                toastElement.remove();
            });
        },
        
        // Render markdown content safely
        renderMarkdown(markdown) {
            if (!markdown) return '';
            
            const rawHtml = marked.parse(markdown);
            
            const parser = new DOMParser();
            const doc = parser.parseFromString(rawHtml, 'text/html');
            doc.querySelectorAll('a').forEach(link => {
                link.setAttribute('target', '_blank');
                link.setAttribute('rel', 'noopener noreferrer');
            });
            
            return DOMPurify.sanitize(doc.body.innerHTML, {
                USE_PROFILES: { html: true },
                ADD_ATTR: ['target', 'rel']
            });
        },
        
        // Find item by ID
        findItemById(items, id) {
            if (!items || !Array.isArray(items) || !id) return null;
            
            for (const item of items) {
                if (item.id === id) return item;
                
                if (item.items && item.items.length > 0) {
                    const found = this.findItemById(item.items, id);
                    if (found) return found;
                }
            }
            return null;
        },
        
        // Find parent of item by ID
        findParentOfItem(items, id, parent = null) {
            if (!items || !Array.isArray(items) || !id) return null;
            
            for (const item of items) {
                if (item.id === id) return parent;
                
                if (item.items && item.items.length > 0) {
                    const found = this.findParentOfItem(item.items, id, item);
                    if (found) return found;
                }
            }
            return null;
        },
        
        // Remove item by ID
        removeItemById(items, id) {
            if (!items || !Array.isArray(items) || !id) return false;
            
            for (let i = 0; i < items.length; i++) {
                if (items[i].id === id) {
                    items.splice(i, 1);
                    return true;
                }
                
                if (items[i].items && items[i].items.length > 0) {
                    if (this.removeItemById(items[i].items, id)) {
                        return true;
                    }
                }
            }
            return false;
        },
        
        // Add new item
        addItem(items, newItem, parentId = null) {
            if (!newItem) return false;
            
            if (!parentId) {
                items.push(newItem);
                return true;
            }
            
            const parent = this.findItemById(items, parentId);
            if (parent) {
                if (!parent.items) parent.items = [];
                
                if (!newItem.id) {
                    newItem.id = this.generateItemId();
                }
                
                parent.items.push(newItem);
                return true;
            }
            
            return false;
        },
        
        // Update an existing item
        updateItem(items, updatedItem) {
            if (!items || !Array.isArray(items) || !updatedItem || !updatedItem.id) {
                return false;
            }

            for (let i = 0; i < items.length; i++) {
                if (items[i].id === updatedItem.id) {
                    // Store any children items from the existing item
                    const children = items[i].items || [];
                    
                    // Create a new item object with updated properties
                    items[i] = {...updatedItem};
                    
                    // Preserve children if not provided in the update
                    if (!items[i].items || items[i].items.length === 0) {
                        items[i].items = children;
                    }
                    
                    return true;
                }
                
                // Recursively search in child items
                if (items[i].items && items[i].items.length > 0) {
                    if (this.updateItem(items[i].items, updatedItem)) {
                        return true;
                    }
                }
            }
            
            return false;
        },
        
        // Filter items by tags
        filterItemsByTags(items, tags) {
            if (tags.includes('all')) return items;
            
            const filteredItems = [];
            
            const processItem = (item) => {
                if (this.itemHasAnyTag(item, tags)) {
                    const newItem = {...item, items: []};
                    filteredItems.push(newItem);
                    
                    if (item.items && item.items.length > 0) {
                        item.items.forEach(child => processItem(child));
                    }
                    return true;
                }
                
                if (item.items && item.items.length > 0) {
                    const matchingChildren = item.items.filter(child => 
                        this.itemHasAnyTagRecursive(child, tags)
                    );
                    
                    if (matchingChildren.length > 0) {
                        const newItem = {...item, items: []};
                        filteredItems.push(newItem);
                        
                        matchingChildren.forEach(child => processItem(child));
                        return true;
                    }
                }
                
                return false;
            };
            
            items.forEach(item => processItem(item));
            return filteredItems;
        },
        
        // Check if item has any of the specified tags
        itemHasAnyTag(item, tags) {
            if (!item.tags) return false;
            
            const itemTags = item.tags.split(',').map(tag => tag.trim()).filter(tag => !tag.startsWith('type:'));
            return tags.some(tag => itemTags.includes(tag));
        },
        
        // Check if item or any child has any of the specified tags
        itemHasAnyTagRecursive(item, tags) {
            if (this.itemHasAnyTag(item, tags)) return true;
            
            if (item.items && item.items.length > 0) {
                return item.items.some(child => this.itemHasAnyTagRecursive(child, tags));
            }
            
            return false;
        },
        
        // Extract all tags from items
        extractAllTags(items) {
            if (!items || !Array.isArray(items)) return [];
            
            const tagSet = new Set();
            
            const processTags = (item) => {
                if (item.tags) {
                    item.tags.split(',').forEach(tag => {
                        const trimmedTag = tag.trim();
                        if (trimmedTag && !trimmedTag.startsWith('type:')) {
                            tagSet.add(trimmedTag);
                        }
                    });
                }
                
                if (item.items && item.items.length > 0) {
                    item.items.forEach(processTags);
                }
            };
            
            items.forEach(processTags);
            return Array.from(tagSet).sort();
        },
        
        // Build HTML for document navigation
        buildDocumentNavigationHtml(items, activeItemId = null, navExpandedItems = {}, depth = 0) {
            if (!items || items.length === 0) return '';
            
            let html = '<ul class="doc-nav">';
            
            items.forEach(item => {
                const isActive = item.id === activeItemId;
                const hasChildren = item.items && item.items.length > 0;
                const isExpanded = navExpandedItems[item.id];
                
                if (hasChildren || depth === 0) {
                    const shouldBeExpanded = depth === 0 ? true : isExpanded; 
                    
                    const listType = this.getTypeFromTags(item.tags) || '';
                    const listIcon = this.getListTypeIcon(listType);
                    
                    html += `
                        <li class="doc-nav-item">
                            <div>
                                ${Array(depth).fill().map(() => 
                                    `<span class="doc-nav-indent"><i class="bi bi-dash"></i></span>`
                                ).join('')}
                                
                                ${hasChildren ? 
                                    `<span class="doc-nav-toggle" data-id="${item.id}">
                                        <i class="bi ${shouldBeExpanded ? 'bi-chevron-down' : 'bi-chevron-right'}"></i>
                                    </span>` : 
                                    `<span class="doc-nav-indent"></span>`
                                }
                                
                                <i class="bi ${listIcon} me-1" style="font-size: 0.8rem;"></i>
                                
                                <a class="doc-nav-link ${isActive ? 'active' : ''}" 
                                   href="#${item.id}" 
                                   data-id="${item.id}"
                                   title="${item.title}">
                                    ${item.title.substring(0, 35)}${item.title.length > 35 ? '...' : ''}
                                </a>
                            </div>
                            ${hasChildren ? 
                                `<div class="collapse ${shouldBeExpanded ? 'show' : ''}" id="nav-collapse-${item.id}">
                                    ${this.buildDocumentNavigationHtml(item.items, activeItemId, navExpandedItems, depth + 1)}
                                </div>` : 
                                ''}
                        </li>
                    `;
                }
            });
            
            html += '</ul>';
            return html;
        },
        
        // Attach event handlers to navigation elements
        attachNavigationHandlers() {
            const navContainer = document.getElementById('document-navigation');
            if (!navContainer) return;
            
            // Toggle handlers
            navContainer.querySelectorAll('.doc-nav-toggle').forEach(toggle => {
                toggle.addEventListener('click', (e) => {
                    e.preventDefault();
                    const itemId = e.currentTarget.dataset.id;
                    if (!itemId) return;
                    
                    const collapseElement = document.getElementById(`nav-collapse-${itemId}`);
                    if (!collapseElement) return;
                    
                    const icon = e.currentTarget.querySelector('i');
                    if (!icon) return;
                    
                    try {
                        const bsCollapse = bootstrap.Collapse.getOrCreateInstance(collapseElement);
                        
                        if (icon.classList.contains('bi-chevron-down')) {
                            bsCollapse.hide();
                            icon.classList.replace('bi-chevron-down', 'bi-chevron-right');
                            window.app?.toggleNavExpansion(itemId, false);
                        } else {
                            bsCollapse.show();
                            icon.classList.replace('bi-chevron-right', 'bi-chevron-down');
                            window.app?.toggleNavExpansion(itemId, true);
                        }
                    } catch (err) {
                        console.error('Navigation toggle error:', err);
                    }
                });
            });
            
            // Link click handlers
            navContainer.querySelectorAll('.doc-nav-link').forEach(link => {
                link.addEventListener('click', (e) => {
                    e.preventDefault();
                    const itemId = e.currentTarget.dataset.id;
                    if (!itemId) return;
                    
                    window.app?.setCurrentItemId(itemId);
                    window.app?.scrollToItem(itemId);
                    
                    // Update active class
                    setTimeout(() => {
                        navContainer.querySelectorAll('.doc-nav-link').forEach(navLink => {
                            navLink.classList.remove('active');
                        });
                        e.currentTarget.classList.add('active');
                    }, 10);
                });
            });
        },
        
        // Show confirmation dialog for drag operations
        showDragConfirmation(source, target, onConfirm, onCancel) {
            const title = `Confirm Move`;
            const message = `Are you sure you want to move the item <strong>${source.title}</strong> ${target ? `to be a child of <strong>${target.title}</strong>` : 'to the top level'}?`;
            
            const modalHtml = `
                <div class="modal fade" id="drag-confirm-modal" tabindex="-1" aria-hidden="true">
                    <div class="modal-dialog">
                        <div class="modal-content">
                            <div class="modal-header">
                                <h5 class="modal-title">${title}</h5>
                                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                            </div>
                            <div class="modal-body">
                                <p>${message}</p>
                            </div>
                            <div class="modal-footer">
                                <button type="button" class="btn btn-secondary" id="drag-cancel-btn" data-bs-dismiss="modal">Cancel</button>
                                <button type="button" class="btn btn-primary" id="drag-confirm-btn">Confirm</button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.insertAdjacentHTML('beforeend', modalHtml);
            const modalElement = document.getElementById('drag-confirm-modal');
            
            const modal = new bootstrap.Modal(modalElement);
            
            document.getElementById('drag-cancel-btn').addEventListener('click', () => {
                if (onCancel) onCancel();
                modalElement.addEventListener('hidden.bs.modal', () => {
                    modalElement.remove();
                });
            });
            
            document.getElementById('drag-confirm-btn').addEventListener('click', () => {
                if (onConfirm) onConfirm();
                modal.hide();
                modalElement.addEventListener('hidden.bs.modal', () => {
                    modalElement.remove();
                });
            });
            
            modal.show();
        },
        
        // Prepare document data for export
        prepareForExport(document) {
            const { title, items } = document;
            
            const cleanItems = (items) => {
                if (!items || !Array.isArray(items)) return [];
                
                return items.map(item => {
                    const cleanItem = {
                        title: item.title || '',
                        content: item.content || '',
                        tags: item.tags || '',
                        items: []
                    };
                    
                    if (item.items && Array.isArray(item.items)) {
                        cleanItem.items = cleanItems(item.items);
                    }
                    
                    return cleanItem;
                });
            };
            
            return {
                title,
                items: cleanItems(items)
            };
        },
        
        // Get local path for markdown info files
        getLocalMarkdownPath(itemTitle) {
            const sanitizedTitle = itemTitle
                .replace(/[^a-zA-Z0-9]+/g, "_")
                .replace(/^_|_$/g, "");
            return `info/docs/pages/sections/${sanitizedTitle}.md`;
        },
        
        // Update related items in info panel
        updateRelatedItems(items, currentItem) {
            if (!currentItem) return;
            
            const relatedItemsContainer = document.getElementById('related-items');
            const relatedItemsList = document.getElementById('related-items-list');
            
            if (!relatedItemsContainer || !relatedItemsList) return;
            
            const relatedItems = this.findRelatedItems(items, currentItem.title);
            
            if (relatedItems.length > 0) {
                relatedItemsContainer.classList.remove('d-none');
                relatedItemsList.innerHTML = '';
                
                relatedItems.forEach(item => {
                    const itemElement = document.createElement('a');
                    itemElement.href = `#${item.id}`;
                    itemElement.className = 'list-group-item list-group-item-action';
                    itemElement.dataset.id = item.id;
                    itemElement.textContent = item.title;
                    
                    itemElement.addEventListener('click', (e) => {
                        e.preventDefault();
                        window.app?.setCurrentItemId(item.id);
                        infoPanel.hide();
                    });
                    
                    relatedItemsList.appendChild(itemElement);
                });
            } else {
                relatedItemsContainer.classList.add('d-none');
            }
        },
        
        // Find items related to a particular title
        findRelatedItems(items, title) {
            if (!items || !Array.isArray(items) || !title) return [];
            
            const titleWords = title.toLowerCase().split(/\s+/).filter(word => word.length > 3);
            const relatedItems = [];
            
            const processItems = (items) => {
                items.forEach(item => {
                    if (item.title === title) return;
                    
                    if (item.tags) {
                        const tags = item.tags.toLowerCase().split(',').map(tag => tag.trim());
                        const matchesTags = titleWords.some(word => tags.includes(word));
                        
                        if (matchesTags) {
                            relatedItems.push(item);
                            return;
                        }
                    }
                    
                    const itemTitle = item.title.toLowerCase();
                    const matchesTitle = titleWords.some(word => itemTitle.includes(word));
                    
                    if (matchesTitle) {
                        relatedItems.push(item);
                    }
                    
                    if (item.items && item.items.length > 0) {
                        processItems(item.items);
                    }
                });
            };
            
            processItems(items);
            return relatedItems;
        },
        
        // Toggle sidebar visibility
        toggleSidebar(collapse) {
            const sidebar = document.getElementById('sidebar');
            const mainContent = document.getElementById('main-content');
            const mainHeader = document.getElementById('main-header');
            const expandSidebarBtn = document.getElementById('expand-sidebar-btn');
            
            if (collapse) {
                sidebar.classList.add('collapsed');
                mainContent.classList.add('expanded');
                mainHeader.classList.add('expanded');
                expandSidebarBtn.classList.remove('d-none');
            } else {
                sidebar.classList.remove('collapsed');
                mainContent.classList.remove('expanded');
                mainHeader.classList.remove('expanded');
                expandSidebarBtn.classList.add('d-none');
            }
        }
    };


    /**
     * Main context provider for application data
     */
    const DataContext = React.createContext(null);

    const DataProvider = ({ children }) => {
        const [items, setItems] = React.useState([]);
        const [filteredItems, setFilteredItems] = React.useState([]);
        const [documentTitle, setDocumentTitle] = React.useState("Untitled Document");
        const [activeTags, setActiveTags] = React.useState(['all']);
        const [currentItemId, setCurrentItemId] = React.useState(null);
        const [expandedItems, setExpandedItems] = React.useState({});
        const [navExpandedItems, setNavExpandedItems] = React.useState({});
        const [chatMessages, setChatMessages] = React.useState([]);
        const [suggestedItems, setSuggestedItems] = React.useState([]);
        const [isInfoPanelOpen, setIsInfoPanelOpen] = React.useState(false);
        const [markdownContent, setMarkdownContent] = React.useState("");
        const [originalFilename, setOriginalFilename] = React.useState("");
        
        // Initialize app from local storage
        React.useEffect(() => {
            const savedData = localStorage.getItem(LOCAL_STORAGE_KEY);
            if (savedData) {
                try {
                    const parsedData = JSON.parse(savedData);
                    setItems(parsedData.items || []);
                    setFilteredItems(parsedData.items || []);
                    setDocumentTitle(parsedData.title || "Untitled Document");
                    
                    const expanded = {};
                    const navExpanded = {};
                    const processItems = (itemList, depth = 0) => {
                        if (!itemList) return;
                        itemList.forEach(item => {
                            if (item && item.id) {
                                expanded[item.id] = true;
                                navExpanded[item.id] = depth === 0;
                                if (item.items && item.items.length > 0) {
                                    processItems(item.items, depth + 1);
                                }
                            }
                        });
                    };
                    processItems(parsedData.items || []);
                    setExpandedItems(expanded);
                    setNavExpandedItems(navExpanded);
                } catch (error) {
                    console.error("Failed to load saved data:", error);
                }
            }
        }, []);
        
        // Save to local storage and update filters when items change
        React.useEffect(() => {
            if (items.length > 0) {
                const dataToSave = {
                    title: documentTitle,
                    items: items
                };
                localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(dataToSave));
            }

            if (activeTags.includes('all')) {
                setFilteredItems(items);
            } else {
                setFilteredItems(Utils.filterItemsByTags(items, activeTags));
            }

            updateDocumentNavigation();
            updateTagFilters();
        }, [items, documentTitle, navExpandedItems]);
        
        // Update tag filters
        React.useEffect(() => {
            if (activeTags.includes('all')) {
                setFilteredItems(items);
            } else {
                setFilteredItems(Utils.filterItemsByTags(items, activeTags));
            }
            
            const tagFilterBtn = document.getElementById('tag-filter-btn');
            if (tagFilterBtn) {
                if (activeTags.includes('all')) {
                    tagFilterBtn.classList.remove('filtering');
                } else {
                    tagFilterBtn.classList.add('filtering');
                }
            }
            
            updateDocumentNavigation();
        }, [activeTags]);

        // Update sidebar state when classes change
        React.useEffect(() => {
            const mainContent = document.getElementById('main-content');
            const mainHeader = document.getElementById('main-header');
            const sidebar = document.getElementById('sidebar');
            const expandSidebarBtn = document.getElementById('expand-sidebar-btn');

            if (window.MutationObserver) {
                const observer = new MutationObserver((mutations) => {
                    mutations.forEach(mutation => {
                        if (mutation.attributeName === 'class') {
                            const isCollapsed = sidebar.classList.contains('collapsed');
                            if (isCollapsed) {
                                mainContent.classList.add('expanded');
                                mainHeader.classList.add('expanded');
                                expandSidebarBtn.classList.remove('d-none');
                            } else {
                                mainContent.classList.remove('expanded');
                                mainHeader.classList.remove('expanded');
                                expandSidebarBtn.classList.add('d-none');
                            }
                        }
                    });
                });
                
                observer.observe(sidebar, { attributes: true });
                return () => observer.disconnect();
            }
        }, []);
        
        // Update related items when current item changes
        React.useEffect(() => {
            if (currentItemId) {
                const currentItem = Utils.findItemById(items, currentItemId);
                if (currentItem) {
                    Utils.updateRelatedItems(items, currentItem);
                }
            }
        }, [currentItemId, items]);
        
        // Update tag filters in UI
        const updateTagFilters = React.useCallback(() => {
            const tagFiltersContainer = document.getElementById('tag-filters');
            if (!tagFiltersContainer) return;
            
            const allTags = Utils.extractAllTags(items);
            
            tagFiltersContainer.innerHTML = '';
            
            if (allTags.length === 0) {
                tagFiltersContainer.innerHTML = '<div class="text-muted">No tags available</div>';
                return;
            }
            
            const allButton = document.createElement('button');
            allButton.className = `btn ${activeTags.includes('all') ? 'btn-secondary' : 'btn-outline-secondary'} w-100 mb-2`;
            allButton.textContent = 'All Tags';
            allButton.addEventListener('click', () => {
                toggleTagFilter('all');
            });
            tagFiltersContainer.appendChild(allButton);
            
            const tagsContainer = document.createElement('div');
            tagsContainer.className = 'd-flex flex-wrap gap-1';
            tagFiltersContainer.appendChild(tagsContainer);
            
            allTags.forEach(tag => {
                const button = document.createElement('button');
                button.className = `btn btn-sm ${activeTags.includes(tag) ? 'btn-secondary' : 'btn-outline-secondary'} me-1 mb-1`;
                button.textContent = tag;
                button.addEventListener('click', () => {
                    toggleTagFilter(tag);
                });
                tagsContainer.appendChild(button);
            });
        }, [items, activeTags]);
        
        // Update document navigation in UI
        const updateDocumentNavigation = React.useCallback(() => {
            const navContainer = document.getElementById('document-navigation');
            if (navContainer) {
                const itemContainers = document.querySelectorAll('.item-container');
                itemContainers.forEach(container => {
                    const id = container.dataset.id;
                    if (id) {
                        container.id = id;
                    }
                });
                
                const itemsToDisplay = activeTags.includes('all') ? items : filteredItems;
                navContainer.innerHTML = Utils.buildDocumentNavigationHtml(itemsToDisplay, currentItemId, navExpandedItems);
                
                navContainer.querySelectorAll('[id^="nav-collapse-"]').forEach(collapse => {
                    new bootstrap.Collapse(collapse, { toggle: false });
                });
                
                Utils.attachNavigationHandlers();
            }
        }, [items, filteredItems, activeTags, currentItemId, navExpandedItems]);
        
        // Update navigation when dependencies change
        React.useEffect(() => {
            updateDocumentNavigation();
        }, [updateDocumentNavigation]);
        
        // Update tag filters when dependencies change
        React.useEffect(() => {
            updateTagFilters();
        }, [updateTagFilters]);
        
        // Toggle navigation item expansion
        const toggleNavExpansion = (id, isExpanded) => {
            setNavExpandedItems(prev => ({...prev, [id]: isExpanded}));
        };
        
        // Scroll to an item by ID
        const scrollToItem = (itemId) => {
            const itemElement = document.getElementById(itemId);
            if (itemElement) {
                let current = itemId;
                while (current) {
                    const parent = Utils.findParentOfItem(items, current);
                    if (parent && parent.id) {
                        setExpandedItems(prev => ({...prev, [parent.id]: true}));
                        current = parent.id;
                    } else {
                        current = null;
                    }
                }
                
                setTimeout(() => {
                    itemElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }, 100);
            }
        };
        
        // Fetch markdown content for info panel
        const fetchMarkdownContent = async (itemTitle) => {
            try {
                const path = Utils.getLocalMarkdownPath(itemTitle);
                
                const response = await fetch(path);
                
                if (!response.ok) {
                    throw new Error(`Error loading file: ${response.status}`);
                }
                
                const text = await response.text();
                setMarkdownContent(text || "No description available for this item.");
                
                const infoPanelContent = document.getElementById('info-panel-content');
                if (infoPanelContent) {
                    infoPanelContent.innerHTML = Utils.renderMarkdown(text);
                }
                
                return text;
            } catch (error) {
                console.log(`Info file not found for: ${itemTitle} - This is expected behavior.`);
                const fallbackContent = `<div class="alert alert-info">
                    <strong>No information available for "${itemTitle}"</strong><br><br>
                    <p>This is normal if you haven't created info files yet.</p>
                    <p>To add information, create a markdown file at this path: <code>${Utils.getLocalMarkdownPath(itemTitle)}</code></p>
                </div>`;
                
                setMarkdownContent(fallbackContent);
                
                const infoPanelContent = document.getElementById('info-panel-content');
                if (infoPanelContent) {
                    infoPanelContent.innerHTML = fallbackContent;
                }
                
                return fallbackContent;
            }
        };
        
        // Reorder items (for drag-and-drop)
        const reorderItems = (sourceId, targetId, newIndex) => {
            if (!sourceId) return;

            setItems(prevItems => {
                try {
                    const newItems = JSON.parse(JSON.stringify(prevItems));
                    
                    // Handle top-level reordering
                    if (!targetId) {
                        for (let i = 0; i < newItems.length; i++) {
                            if (newItems[i].id === sourceId) {
                                const [movedItem] = newItems.splice(i, 1);
                                newItems.splice(newIndex, 0, movedItem);
                                return newItems;
                            }
                        }
                    }
                    
                    // Handle reordering within a parent
                    const findAndReorder = (items) => {
                        for (const item of items) {
                            if (item.id === targetId && item.items) {
                                for (let i = 0; i < item.items.length; i++) {
                                    if (item.items[i].id === sourceId) {
                                        const [movedItem] = item.items.splice(i, 1);
                                        item.items.splice(newIndex, 0, movedItem);
                                        return true;
                                    }
                                }
                            }
                            
                            if (item.items && item.items.length > 0) {
                                if (findAndReorder(item.items)) {
                                    return true;
                                }
                            }
                        }
                        return false;
                    };
                    
                    findAndReorder(newItems);
                    return newItems;
                } catch (error) {
                    console.error("Error during item reordering:", error);
                    return prevItems;
                }
            });
        };
        
        // Add a new item with UUID approach
        const addItem = (newItem, parentId = null) => {
            if (!newItem.title) {
                Utils.showAlert("Item title is required", "danger");
                return false;
            }

            // Always generate a new unique ID
            if (!newItem.id) {
                newItem.id = Utils.generateItemId();
            }
            
            setItems(prevItems => {
                try {
                    const newItems = JSON.parse(JSON.stringify(prevItems));
                    const success = Utils.addItem(newItems, newItem, parentId);
                    
                    if (!success) {
                        throw new Error("Failed to add item");
                    }
                    
                    return newItems;
                } catch (err) {
                    console.error("Error adding item:", err);
                    Utils.showAlert(`Error adding item: ${err.message}`, "danger");
                    return prevItems;
                }
            });
            
            // Expand parent item if adding a child
            if (parentId) {
                setExpandedItems(prev => ({...prev, [parentId]: true}));
            }
            
            Utils.showAlert(`Item "${newItem.title}" has been added.`, "success");
            return true;
        };
        
        // Update an existing item - simplified for UUID approach
        const updateItem = (updatedItem) => {
            if (!updatedItem || !updatedItem.id) {
                Utils.showAlert("Cannot update: Invalid item data", "danger");
                return false;
            }
            
            setItems(prevItems => {
                try {
                    const newItems = JSON.parse(JSON.stringify(prevItems));
                    
                    // Find and update item by ID (which never changes)
                    const findAndUpdateItem = (items) => {
                        for (let i = 0; i < items.length; i++) {
                            if (items[i].id === updatedItem.id) {
                                // Store any children from the existing item
                                const children = items[i].items || [];
                                
                                // Replace the entire item
                                items[i] = {...updatedItem};
                                
                                // Preserve children if not provided in the update
                                if (!items[i].items || items[i].items.length === 0) {
                                    items[i].items = children;
                                }
                                
                                return true;
                            }
                            
                            // Recursively search in children
                            if (items[i].items && items[i].items.length > 0) {
                                if (findAndUpdateItem(items[i].items)) {
                                    return true;
                                }
                            }
                        }
                        return false;
                    };
                    
                    const updated = findAndUpdateItem(newItems);
                    
                    if (!updated) {
                        console.warn(`Item with ID ${updatedItem.id} not found in current items`);
                        return prevItems;
                    }
                    
                    return newItems;
                } catch (err) {
                    console.error("Error updating item:", err);
                    Utils.showAlert(`Error updating item: ${err.message}`, "danger");
                    return prevItems;
                }
            });
            
            return true;
        };
        
        // Remove an item
        const removeItem = (id) => {
            if (!id) {
                Utils.showAlert("Cannot delete: Item ID is missing", "danger");
                return false;
            }
            
            setItems(prevItems => {
                try {
                    const newItems = JSON.parse(JSON.stringify(prevItems));
                    const removed = Utils.removeItemById(newItems, id);
                    
                    if (!removed) {
                        console.warn(`Item with ID ${id} not found for deletion`);
                    }
                    
                    return newItems;
                } catch (err) {
                    console.error("Error removing item:", err);
                    return prevItems;
                }
            });
            
            Utils.showAlert("Item has been deleted.", "success");
            return true;
        };
        
        // Clear the entire document
        const clearDocument = () => {
            setItems([]);
            setFilteredItems([]);
            setDocumentTitle("Untitled Document");
            setCurrentItemId(null);
            setExpandedItems({});
            setNavExpandedItems({});
            setChatMessages([]);
            setSuggestedItems([]);
            setOriginalFilename("");
            localStorage.removeItem(LOCAL_STORAGE_KEY);
            Utils.showAlert("Document has been cleared.", "success");
        };
        
        // Import a document with UUID generation
        const importDocument = (data, filename = "") => {
            setChatMessages([]);
            setSuggestedItems([]);
            setCurrentItemId(null);
            
            if (!data || !data.items || !Array.isArray(data.items)) {
                Utils.showAlert("Invalid document format. Missing items array.", "danger");
                return false;
            }
            
            // Generate new UUIDs for all items
            const generateIds = (items) => {
                if (!items) return;
                
                for (const item of items) {
                    item.id = Utils.generateItemId();
                    
                    if (item.items && item.items.length > 0) {
                        generateIds(item.items);
                    }
                }
            };
            
            // Generate all new IDs
            generateIds(data.items);
            
            setItems(data.items);
            setFilteredItems(data.items);
            setActiveTags(['all']);
            
            if (filename) {
                // Remove timestamp from filename if present (format: YYYY-MM-DD-HH-MM-SS)
                const filenameWithoutExtension = filename.replace(/\.(json)$/, '')
                                                        .replace(/_\d{4}-\d{2}-\d{2}-\d{2}-\d{2}-\d{2}$/, '');
                setDocumentTitle(filenameWithoutExtension);
                setOriginalFilename(filenameWithoutExtension);
            } else {
                setDocumentTitle(data.title || "Imported Document");
            }
            
            const expanded = {};
            const navExpanded = {};
            
            const processItems = (itemList, depth = 0) => {
                if (!itemList) return;
                itemList.forEach(item => {
                    if (item && item.id) {
                        expanded[item.id] = true;
                        navExpanded[item.id] = depth === 0;
                        
                        if (item.items && item.items.length > 0) {
                            processItems(item.items, depth + 1);
                        }
                    }
                });
            };
            
            processItems(data.items);
            
            setExpandedItems(expanded);
            setNavExpandedItems(navExpanded);
            
            setTimeout(() => {
                updateDocumentNavigation();
                updateTagFilters();
            }, 100);
            
            Utils.showAlert("Document imported successfully.", "success");
            return true;
        };
        
        // Export document to Markdown
        const exportToMarkdown = (data) => {
            const processItem = (item, level = 2) => {
                const result = [];
                
                const tags = item.tags 
                    ? item.tags.split(',').filter(tag => !tag.startsWith('type:'))
                                 .map(tag => `#${tag.trim()}`)
                                 .join(' ') 
                    : '';
                    
                const title = tags ? `${item.title} ${tags}` : item.title;
                result.push({ [`h${Math.min(level, 6)}`]: title });
                
                if (item.content) {
                    result.push({ p: item.content });
                }
                
                if (item.items && item.items.length > 0) {
                    item.items.forEach(child => {
                        result.push(...processItem(child, level + 1));
                    });
                }
                
                return result;
            };
            
            const mdArray = [
                { h1: data.title },
                ...data.items.flatMap(item => processItem(item))
            ];
            
            return json2md(mdArray);
        };
        
        // Export document to DOCX
        const exportToDOCX = async (data) => {
            const { Document, Packer, Paragraph, TextRun, HeadingLevel, AlignmentType } = window.docx;
            
            const processDocxItem = (item, level = 1) => {
                const children = [];
                
                children.push(new Paragraph({
                    text: item.title,
                    heading: level <= 6 ? `Heading${level}` : undefined,
                    spacing: { after: 200 }
                }));
                
                if (item.tags) {
                    const tags = item.tags.split(',').filter(tag => !tag.startsWith('type:'));
                    if (tags.length > 0) {
                        children.push(new Paragraph({
                            children: tags.map(tag => new TextRun({
                                text: tag.trim() + " ",
                                size: 20,
                                color: "666666",
                                italics: true
                            })),
                            spacing: { after: 200 }
                        }));
                    }
                }
                
                if (item.content) {
                    const lines = item.content.split('\n');
                    lines.forEach(line => {
                        if (line.trim()) {
                            children.push(new Paragraph({
                                text: line,
                                spacing: { after: 120 }
                            }));
                        }
                    });
                }
                
                if (item.items && item.items.length > 0) {
                    item.items.forEach(child => {
                        children.push(...processDocxItem(child, level + 1));
                    });
                }
                
                return children;
            };
            
            const doc = new Document({
                sections: [{
                    children: [
                        new Paragraph({
                            text: data.title,
                            heading: HeadingLevel.TITLE,
                            spacing: { after: 400 },
                            alignment: AlignmentType.CENTER
                        }),
                        ...data.items.flatMap(item => processDocxItem(item))
                    ]
                }]
            });
            
            const blob = await Packer.toBlob(doc);
            const timestamp = new Date().toISOString()
                .replace(/T/, '-')
                .replace(/\..+/, '')
                .replace(/:/g, '-')
                .substring(0, 19);
            
            saveAs(blob, `${originalFilename || documentTitle.replace(/\s+/g, '_')}_${timestamp}.docx`);
            
            Utils.showAlert(`Document exported as DOCX successfully.`, "success");
        };
        
        // Export document to CSV
        const exportToCSV = (data) => {
            const flatItems = [];
            
            const flattenItems = (items, depth = 0, parentTitle = '') => {
                if (!items || !Array.isArray(items)) return;
                
                items.forEach(item => {
                    if (!item || !item.title) {
                        console.warn("Item without title found, will be omitted from CSV");
                        return;
                    }
                    
                    flatItems.push({
                        Depth: depth,
                        Title: item.title,
                        ParentItem: parentTitle || '', 
                        Content: item.content || '',
                        Tags: item.tags || ''
                    });
                    
                    if (item.items && item.items.length > 0) {
                        flattenItems(item.items, depth + 1, item.title);
                    }
                });
            };
            
            flattenItems(data.items);
            
            if (flatItems.length === 0) {
                Utils.showAlert("No items to export to CSV", "warning");
                return;
            }
            
            const ws = XLSX.utils.json_to_sheet(flatItems);
            const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, data.title || "Document");
            
            const timestamp = new Date().toISOString()
                .replace(/T/, '-')
                .replace(/\..+/, '')
                .replace(/:/g, '-')
                .substring(0, 19);
                
            try {
                XLSX.writeFile(wb, `${originalFilename || documentTitle.replace(/\s+/g, '_')}_${timestamp}.csv`);
                Utils.showAlert(`Document exported as CSV successfully.`, "success");
            } catch (error) {
                console.error("Error saving CSV file:", error);
                Utils.showAlert(`Export error: ${error.message}`, "danger");
            }
        };
        
        // Export document in various formats
        const exportDocument = (format = 'json') => {
            const dataForExport = Utils.prepareForExport({
                title: documentTitle,
                items: items
            });
            
            let blob, url, filename, content;
            const timestamp = new Date().toISOString()
                .replace(/T/, '-')
                .replace(/\..+/, '')
                .replace(/:/g, '-')
                .substring(0, 19);
            
            switch(format) {
                case 'markdown':
                    content = exportToMarkdown(dataForExport);
                    blob = new Blob([content], { type: "text/markdown" });
                    filename = `${originalFilename || documentTitle.replace(/\s+/g, '_')}_${timestamp}.md`;
                    break;
                    
                case 'docx':
                    exportToDOCX(dataForExport);
                    return;
                    
                case 'csv':
                    exportToCSV(dataForExport);
                    return;
                    
                case 'json':
                default:
                    content = JSON.stringify(dataForExport, null, 2);
                    blob = new Blob([content], { type: "application/json" });
                    filename = `${originalFilename || documentTitle.replace(/\s+/g, '_')}_${timestamp}.json`;
                    break;
            }
            
            url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = filename;
            
            document.body.appendChild(a);
            a.click();
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 100);
            
            Utils.showAlert(`Document exported as ${format.toUpperCase()} successfully.`, "success");
        };
        
        // Toggle item expansion in UI
        const toggleItemExpansion = (id) => {
            setExpandedItems(prev => ({...prev, [id]: !prev[id]}));
        };
        
        // Toggle tag filter
        const toggleTagFilter = (tag) => {
            setActiveTags(prev => {
                if (tag === 'all') return ['all'];
                
                if (prev.includes(tag)) {
                    const newTags = prev.filter(t => t !== tag);
                    return newTags.length === 0 || (newTags.length === 1 && newTags[0] === 'all') 
                        ? ['all'] 
                        : newTags;
                } else {
                    return [...prev.filter(t => t !== 'all'), tag];
                }
            });
        };
        
        // Send message to AI Assistant
        const sendChatMessage = async (message) => {
            if (!message.trim()) return;
            
            const chatLoading = document.getElementById('chat-loading');
            if (chatLoading) {
                chatLoading.classList.remove('d-none');
            }
            
            setChatMessages(prev => [...prev, { text: message, sender: 'user' }]);
            
            try {
                const currentItem = Utils.findItemById(items, currentItemId);
                if (!currentItem) {
                    throw new Error("No item selected for context");
                }
                
                const sessionId = `strudol-session-${Date.now()}`;
                
                const payload = {
                    question: message,
                    sectionId: currentItem.id,
                    sectionTitle: currentItem.title,
                    sectionContent: currentItem.content || "No content available.",
                    context_string: `This question is about the ${currentItem.title} item of the document.
                        Content: ${currentItem.content?.substring(0, 500) || "No content"}.
                        The user is asking: ${message}`,
                    context: { items },
                    sessionId
                };
                
                const response = await fetch(WEBHOOK_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    body: JSON.stringify(payload),
                });
                
                if (!response.ok) {
                    throw new Error(`Server responded with status: ${response.status}`);
                }
                
                const responseData = await response.json();
                
                if (Array.isArray(responseData) && responseData.length > 0) {
                    const firstResponse = responseData[0];
                    
                    if (firstResponse.message) {
                        setChatMessages(prev => [...prev, { 
                            text: firstResponse.message, 
                            sender: 'chatbot' 
                        }]);
                    }
                    
                    if (firstResponse.suggestedItems && 
                        firstResponse.suggestedItems.items && 
                        Array.isArray(firstResponse.suggestedItems.items)) {
                        
                        processSuggestedItems(firstResponse.suggestedItems.items, currentItem);
                    }
                } else if (responseData.message) {
                    setChatMessages(prev => [...prev, { 
                        text: responseData.message, 
                        sender: 'chatbot' 
                    }]);
                    
                    if (responseData.suggestedItems && 
                        responseData.suggestedItems.items && 
                        Array.isArray(responseData.suggestedItems.items)) {
                        
                        processSuggestedItems(responseData.suggestedItems.items, currentItem);
                    }
                } else {
                    setChatMessages(prev => [...prev, { 
                        text: "I received a response but couldn't understand it. Please try again.", 
                        sender: 'chatbot' 
                    }]);
                }
            } catch (error) {
                console.error("Error in chatbot communication:", error);
                
                setChatMessages(prev => [...prev, { 
                    text: `Sorry, there was an error: ${error.message}. Please try again.`, 
                    sender: 'chatbot' 
                }]);
            } finally {
                if (chatLoading) {
                    chatLoading.classList.add('d-none');
                }
                
                updateChatDisplay();
            }
        };

        // Process suggested items from AI
        const processSuggestedItems = (suggestedItemsArray, currentItem) => {
            if (!Array.isArray(suggestedItemsArray) || !currentItem) {
                console.warn("Invalid suggested items or missing current item");
                return;
            }

            const suggestions = suggestedItemsArray.map((item, index) => ({
                id: Utils.generateItemId(),
                title: item.name || 'Unnamed Item',
                content: item.content || '',
                tags: item.tags || '',
                isSuggestion: true
            }));
            
            setSuggestedItems(suggestions);
            updateSuggestedItemsDisplay(suggestions);
        };

        // Update chat display
        const updateChatDisplay = () => {
            const chatMessagesContainer = document.getElementById('chat-messages');
            if (chatMessagesContainer) {
                chatMessagesContainer.innerHTML = '';
                
                chatMessages.forEach((msg) => {
                    const messageElement = document.createElement('div');
                    messageElement.className = `${msg.sender === 'user' ? 'alert alert-secondary' : 'alert alert-primary'} mb-2`;
                    messageElement.innerHTML = Utils.renderMarkdown(msg.text);
                    chatMessagesContainer.appendChild(messageElement);
                });
                
                chatMessagesContainer.scrollTop = chatMessagesContainer.scrollHeight;
            }
        };

        // Update suggested items display
        const updateSuggestedItemsDisplay = (suggestions) => {
            const suggestedItemsContainer = document.getElementById('suggested-items-list');
            if (suggestedItemsContainer) {
                suggestedItemsContainer.innerHTML = '';
                
                if (!suggestions || suggestions.length === 0) {
                    suggestedItemsContainer.innerHTML = '<div class="alert alert-info">No suggested items available yet.</div>';
                    return;
                }
                
                suggestions.forEach((item) => {
                    const itemElement = document.createElement('div');
                    itemElement.className = 'card mb-2';
                    itemElement.draggable = true;
                    itemElement.dataset.id = item.id;
                    
                    itemElement.addEventListener('dragstart', (e) => {
                        e.dataTransfer.setData('text/plain', JSON.stringify(item));
                    });
                    
                    itemElement.innerHTML = `
                        <div class="card-body">
                            <h6 class="card-title">${item.title}</h6>
                            <p class="card-text small">${item.content.substring(0, 100)}${item.content.length > 100 ? '...' : ''}</p>
                            <div class="d-flex justify-content-between align-items-center">
                                ${item.tags ? `<div class="item-tags">${item.tags.split(',').map(tag => 
                                    `<span class="badge bg-secondary me-1">${tag.trim()}</span>`).join('')}
                                </div>` : ''}
                                <button class="btn btn-sm btn-primary add-suggestion-btn">
                                    <i class="bi bi-plus-circle me-1"></i> Add
                                </button>
                            </div>
                        </div>
                    `;
                    
                    itemElement.querySelector('.add-suggestion-btn').addEventListener('click', () => {
                        if (currentItemId) {
                            addItem({
                                id: item.id,
                                title: item.title,
                                content: item.content,
                                tags: item.tags,
                                items: []
                            }, currentItemId);
                        } else {
                            addItem({
                                id: item.id,
                                title: item.title,
                                content: item.content,
                                tags: item.tags,
                                items: []
                            });
                        }
                    });
                    
                    suggestedItemsContainer.appendChild(itemElement);
                });
            }
        };
        
        // Context value for provider
        const contextValue = {
            // State
            items,
            filteredItems,
            documentTitle,
            activeTags,
            currentItemId,
            expandedItems,
            navExpandedItems,
            chatMessages,
            suggestedItems,
            isInfoPanelOpen,
            markdownContent,
            originalFilename,
            
            // State setters
            setItems,
            setFilteredItems,
            setDocumentTitle,
            setCurrentItemId,
            setOriginalFilename,
            setIsInfoPanelOpen,
            
            // Action methods
            addItem,
            updateItem,
            removeItem,
            clearDocument,
            toggleItemExpansion,
            toggleNavExpansion,
            toggleTagFilter,
            importDocument,
            exportDocument,
            sendChatMessage,
            setSuggestedItems,
            fetchMarkdownContent,
            updateDocumentNavigation,
            updateTagFilters,
            scrollToItem,
            reorderItems
        };
        
        return (
            <DataContext.Provider value={contextValue}>
                {children}
            </DataContext.Provider>
        );
    };

    /**
     * Item component - Renders a single item
     */
    const Item = ({ item, depth = 0 }) => {
        const context = React.useContext(DataContext);
        if (!context) return <div>Loading...</div>;
        
        const {
            currentItemId,
            expandedItems,
            toggleItemExpansion,
            setCurrentItemId,
            setIsInfoPanelOpen,
            fetchMarkdownContent,
            reorderItems
        } = context;
        
        const isExpanded = expandedItems[item.id];
        const hasChildren = item.items && item.items.length > 0;
        const isSelected = currentItemId === item.id;
        
        const itemRef = React.useRef(null);
        const listType = Utils.getTypeFromTags(item.tags) || '';
        const listIcon = Utils.getListTypeIcon(listType);
        const listClass = listType ? `list-${listType}` : '';
        
        // Setup sortable for drag-and-drop
        React.useEffect(() => {
            if (itemRef.current && hasChildren && isExpanded) {
                const sortable = new Sortable(itemRef.current, {
                    group: 'items',
                    animation: 150,
                    ghostClass: 'sortable-ghost',
                    chosenClass: 'sortable-chosen',
                    handle: '.item-drag-handle',
                    onEnd: function(evt) {
                        if (!item.items || evt.oldIndex === undefined || evt.newIndex === undefined) {
                            return;
                        }
                        
                        if (evt.oldIndex < 0 || evt.oldIndex >= item.items.length ||
                            evt.newIndex < 0 || evt.newIndex >= item.items.length) {
                            return;
                        }

                        const sourceItem = item.items[evt.oldIndex];
                        if (!sourceItem) return;

                        const targetItem = item;
                        const originalItems = [...item.items];
                        
                        Utils.showDragConfirmation(
                            sourceItem, 
                            targetItem,
                            () => {
                                reorderItems(sourceItem.id, item.id, evt.newIndex);
                                Utils.showAlert(`Item "${sourceItem.title}" moved successfully.`, "success");
                            },
                            () => {
                                evt.from.classList.add('restoring');
                                setTimeout(() => {
                                    evt.from.innerHTML = '';
                                    originalItems.forEach(child => {
                                        const placeholder = document.createElement('div');
                                        placeholder.className = 'item-placeholder';
                                        placeholder.dataset.id = child.id;
                                        placeholder.innerHTML = '<div class="p-2">Restoring...</div>';
                                        evt.from.appendChild(placeholder);
                                    });
                                    
                                    setTimeout(() => {
                                        context.updateDocumentNavigation();
                                        context.setItems(prevItems => [...prevItems]); 
                                        evt.from.classList.remove('restoring');
                                    }, 50);
                                }, 50);
                            }
                        );
                    }
                });
                
                return () => sortable.destroy();
            }
        }, [hasChildren, isExpanded, item.items, context, reorderItems]);
        
        // Open item editor modal
        const openEditModal = () => {
            const modalElement = document.getElementById('item-editor-modal');
            const modal = new bootstrap.Modal(modalElement);
            const titleInput = document.getElementById('item-title');
            const tagsInput = document.getElementById('item-tags');
            const contentInput = document.getElementById('item-content');
            const idInput = document.getElementById('item-id');
            const parentIdInput = document.getElementById('parent-id');
            
            // Fill the form with current values
            titleInput.value = item.title || '';
            tagsInput.value = item.tags || '';
            contentInput.value = item.content || '';
            idInput.value = item.id;  // Critical: Set the ID
            parentIdInput.value = '';
            
            // Initialize SimpleMDE
            if (window.simpleMDE) {
                window.simpleMDE.value(item.content || '');
                setTimeout(() => window.simpleMDE.codemirror.refresh(), 10);
            } else {
                window.simpleMDE = new SimpleMDE({ 
                    element: contentInput,
                    spellChecker: false,
                    status: false
                });
            }
            
            // Initialize Tagify
            if (!window.tagify) {
                window.tagify = new Tagify(tagsInput, {
                    dropdown: {
                        enabled: 1,
                        maxItems: 5
                    }
                });
                if (item.tags) {
                    window.tagify.addTags(item.tags);
                }
            } else {
                window.tagify.removeAllTags();
                if (item.tags) {
                    window.tagify.addTags(item.tags);
                }
            }
            
            document.getElementById('item-editor-title').textContent = 'Edit Item';
            modal.show();
        };
        
        // Open chatbot panel
        const openChatbotPanel = () => {
            setCurrentItemId(item.id);
            
            const contextSpan = document.getElementById('current-item-title');
            if (contextSpan) contextSpan.textContent = item.title;
            
            chatbotPanel.show();
        };
        
        // Open info panel
        const openInfoPanel = async () => {
            setCurrentItemId(item.id);
            await fetchMarkdownContent(item.title);
            setIsInfoPanelOpen(true);
            
            const panelTitle = document.getElementById('info-panel-title');
            if (panelTitle) panelTitle.textContent = `About ${item.title}`;
            
            infoPanel.show();
            
            Utils.updateRelatedItems(context.items, item);
        };
        
        // Add child item
        const addChildItem = () => {
            const modalElement = document.getElementById('item-editor-modal');
            const modal = new bootstrap.Modal(modalElement);
            const titleInput = document.getElementById('item-title');
            const tagsInput = document.getElementById('item-tags');
            const contentInput = document.getElementById('item-content');
            const idInput = document.getElementById('item-id');
            const parentIdInput = document.getElementById('parent-id');
            
            titleInput.value = '';
            tagsInput.value = '';
            contentInput.value = '';
            idInput.value = '';
            parentIdInput.value = item.id;
            
            if (window.simpleMDE) {
                window.simpleMDE.value('');
                setTimeout(() => window.simpleMDE.codemirror.refresh(), 10);
            } else {
                window.simpleMDE = new SimpleMDE({ 
                    element: contentInput,
                    spellChecker: false,
                    status: false
                });
            }
            
            if (!window.tagify) {
                window.tagify = new Tagify(tagsInput, {
                    dropdown: {
                        enabled: 1,
                        maxItems: 5
                    }
                });
            } else {
                window.tagify.removeAllTags();
            }
            
            document.getElementById('item-editor-title').textContent = 'Add New Item';
            modal.show();
        };
        
        // Render tags
        const renderTags = () => {
            if (!item.tags) return null;
            
            return item.tags.split(',').map((tag, index) => {
                const trimmedTag = tag.trim();
                if (!trimmedTag) return null;
                
                const isSpecial = trimmedTag.startsWith('type:');
                
                if (isSpecial) return null;
                
                return (
                    <span key={`${item.id}-tag-${index}`} className={`item-tag ${isSpecial ? 'special-tag' : ''}`}>
                        {trimmedTag}
                    </span>
                );
            }).filter(tag => tag !== null);
        };
        
        return (
            <div className={`item-container ${listClass} ${hasChildren ? 'has-children' : ''}`} id={item.id} data-id={item.id}>
                <div className={`item-header ${isSelected ? 'bg-light' : ''}`}>
                    <div className="item-title-area">
                        {hasChildren ? (
                            <button 
                                className="btn btn-sm btn-link p-0 me-2"
                                onClick={() => toggleItemExpansion(item.id)}
                            >
                                <i className={`bi ${isExpanded ? 'bi-chevron-down' : 'bi-chevron-right'}`}></i>
                            </button>
                        ) : (
                            <span style={{ width: '0.4rem' }}></span>
                        )}
                        
                        <div className="item-icon">
                            <i className={`bi ${listIcon}`}></i>
                        </div>
                        
                        <h5 className="item-title">{item.title}</h5>
                        
                        <div className="item-tags">
                            {renderTags()}
                        </div>
                        
                        <div className="item-actions">
                            <span className="item-drag-handle action-btn">
                                <i className="bi bi-arrows-move"></i>
                            </span>
                            
                            <button 
                                className="action-btn"
                                onClick={openEditModal}
                                title="Edit this item"
                            >
                                <i className="bi bi-pencil"></i>
                            </button>
                            
                            <button
                                className="action-btn"
                                onClick={openChatbotPanel}
                                title="Ask AI about this item"
                            >
                                <i className="bi bi-chat-dots"></i>
                            </button>
                            
                            <button
                                className="action-btn"
                                onClick={openInfoPanel}
                                title="Learn more about this concept"
                            >
                                <i className="bi bi-info-circle"></i>
                            </button>
                            
                            <button
                                className="action-btn add-btn"
                                onClick={addChildItem}
                                title="Add a child item"
                            >
                                <i className="bi bi-plus-circle"></i>
                            </button>
                        </div>
                    </div>
                </div>
                
                <div className="item-content">
                    {item.content && (
                        <div 
                            className="markdown-content"
                            dangerouslySetInnerHTML={{ __html: Utils.renderMarkdown(item.content) }}
                        ></div>
                    )}
                </div>
                
                {hasChildren && (
                    <div 
                        ref={itemRef}
                        className={`item-children collapse ${isExpanded ? 'show' : ''}`}
                        id={`collapse-${item.id}`}
                    >
                        {item.items.map((child, index) => (
                            <Item 
                                key={child.id || `${item.id}-child-${index}`} 
                                item={child} 
                                depth={depth + 1}
                            />
                        ))}
                    </div>
                )}
            </div>
        );
    };

    /**
     * Document component - Renders the entire document
     */
    const Document = () => {
        const context = React.useContext(DataContext);
        const [tempUpdate, setTempUpdate] = React.useState(false);
        
        if (!context) {
            return <div>Loading document context...</div>;
        }
        
        const { 
            items, 
            filteredItems,
            activeTags,
            updateDocumentNavigation,
            reorderItems
        } = context;
        
        const documentRef = React.useRef(null);
        const displayItems = activeTags.includes('all') ? items : filteredItems;
        
        // Handle imported data event
        React.useEffect(() => {
            const handleImportedData = () => setTempUpdate(prev => !prev);
            document.addEventListener('app-imported-data', handleImportedData);
            return () => document.removeEventListener('app-imported-data', handleImportedData);
        }, []);
        
        // Setup sortable for top-level items
        React.useEffect(() => {
            if (documentRef.current) {
                const sortable = new Sortable(documentRef.current, {
                    group: 'items',
                    animation: 150,
                    ghostClass: 'sortable-ghost',
                    chosenClass: 'sortable-chosen',
                    handle: '.item-drag-handle',
                    onEnd: function(evt) {
                        const currentItems = activeTags.includes('all') ? items : filteredItems;
                        
                        if (evt.oldIndex < 0 || evt.oldIndex >= currentItems.length || 
                            evt.newIndex < 0 || evt.newIndex >= currentItems.length) {
                            return;
                        }
                        
                        const sourceItem = currentItems[evt.oldIndex];
                        if (!sourceItem) return;
                        
                        Utils.showDragConfirmation(
                            sourceItem, 
                            null,
                            () => {
                                const newItems = [...items];
                                
                                let sourceIndex = -1;
                                for (let i = 0; i < newItems.length; i++) {
                                    if (newItems[i] && newItems[i].id === sourceItem.id) {
                                        sourceIndex = i;
                                        break;
                                    }
                                }
                                
                                if (sourceIndex >= 0) {
                                    const [movedItem] = newItems.splice(sourceIndex, 1);
                                    newItems.splice(evt.newIndex, 0, movedItem);
                                    
                                    context.setItems(newItems);
                                    Utils.showAlert(`Item "${sourceItem.title}" moved successfully.`, "success");
                                }
                            },
                            () => {
                                context.setItems([...items]);
                            }
                        );
                    }
                });
                
                return () => sortable.destroy();
            }
        }, [items, filteredItems, displayItems, context, activeTags, reorderItems]);

        // Update document navigation when items change
        React.useEffect(() => {
            updateDocumentNavigation();
        }, [items, filteredItems, activeTags, updateDocumentNavigation]);
        
        // Open add item modal
        const handleAddTopLevelItem = () => {
            const modalElement = document.getElementById('item-editor-modal');
            const modal = new bootstrap.Modal(modalElement);
            const titleInput = document.getElementById('item-title');
            const tagsInput = document.getElementById('item-tags');
            const contentInput = document.getElementById('item-content');
            const idInput = document.getElementById('item-id');
            const parentIdInput = document.getElementById('parent-id');
            
            titleInput.value = '';
            tagsInput.value = '';
            contentInput.value = '';
            idInput.value = '';
            parentIdInput.value = '';
            
            if (window.simpleMDE) {
                window.simpleMDE.value('');
                setTimeout(() => window.simpleMDE.codemirror.refresh(), 10);
            } else {
                window.simpleMDE = new SimpleMDE({ 
                    element: contentInput,
                    spellChecker: false,
                    status: false
                });
            }
            
            if (!window.tagify) {
                window.tagify = new Tagify(tagsInput, {
                    dropdown: {
                        enabled: 1,
                        maxItems: 5
                    }
                });
            } else {
                window.tagify.removeAllTags();
            }
            
            document.getElementById('item-editor-title').textContent = 'Add New Item';
            modal.show();
        };
        
        return (
            <div className="document-container">
                <div ref={documentRef} className="items-container">
                    {displayItems && displayItems.length > 0 ? (
                        displayItems.map((item, index) => (
                            <Item key={item.id || `item-${index}`} item={item} />
                        ))
                    ) : (
                        <div className="text-center py-5">
                            <p className="lead">
                                {activeTags.includes('all') ? (
                                    'No items yet. Create your first item to get started.'
                                ) : (
                                    'No items found with the selected tags.'
                                )}
                            </p>
                            {activeTags.includes('all') && (
                                <button 
                                    className="btn btn-primary"
                                    onClick={handleAddTopLevelItem}
                                >
                                    <i className="bi bi-plus-circle me-2"></i> Add First Item
                                </button>
                            )}
                        </div>
                    )}
                </div>
            </div>
        );
    };

    /**
     * App component - Main application component
     */
    const App = () => {
        const [isInitialized, setIsInitialized] = React.useState(false);
        
        // Initialize event handlers and listeners
        React.useEffect(() => {
            // Event listeners for modals and UI elements
            initUIEventHandlers();
            
            // Load data from local storage if available
            const savedData = localStorage.getItem(LOCAL_STORAGE_KEY);
            if (savedData) {
                try {
                    const parsedData = JSON.parse(savedData);
                    if (parsedData.items && parsedData.items.length > 0) {
                        initializeApp(parsedData);
                    }
                } catch (error) {
                    console.error("Failed to load saved data:", error);
                }
            }
            
            // Cleanup function
            return () => cleanupEventListeners();
        }, []);
        
        // Initialize the UI event handlers
        const initUIEventHandlers = () => {
            // Fix modal accessibility issues
            document.getElementById('item-editor-modal').addEventListener('hidden.bs.modal', function () {
                document.getElementById('document-title').focus();
            });

            document.getElementById('item-editor-modal').addEventListener('shown.bs.modal', function () {
                document.getElementById('item-title').focus();
            });

            // Get UI elements
            const welcomeScreen = document.getElementById('welcome-screen');
            const documentContent = document.getElementById('document-content');
            const collapseSidebarBtn = document.getElementById('collapse-sidebar-btn');
            const expandSidebarBtn = document.getElementById('expand-sidebar-btn');
            const fileDropzone = document.getElementById('file-dropzone');
            const fileInput = document.getElementById('file-input');
            const createNewBtn = document.getElementById('create-new-btn');
            const importBtn = document.getElementById('import-btn');
            const clearBtn = document.getElementById('clear-btn');
            const chatInput = document.getElementById('chat-input');
            const chatSendBtn = document.getElementById('chat-send-btn');
            const chatOpenBtn = document.getElementById('chat-open-btn');
            const addTopItemBtn = document.getElementById('add-top-item-btn');
            
            // Sidebar toggle handlers
            collapseSidebarBtn.addEventListener('click', () => {
                Utils.toggleSidebar(true);
            });
            
            expandSidebarBtn.addEventListener('click', () => {
                Utils.toggleSidebar(false);
            });
            
            // Export handlers
            document.getElementById('export-json-btn').addEventListener('click', () => {
                window.app?.exportDocument('json');
            });

            document.getElementById('export-md-btn').addEventListener('click', () => {
                window.app?.exportDocument('markdown');
            });

            document.getElementById('export-html-btn').addEventListener('click', () => {
                window.app?.exportDocument('html');
            });

            document.getElementById('export-docx-btn').addEventListener('click', () => {
                window.app?.exportDocument('docx');
            });

            document.getElementById('export-csv-btn').addEventListener('click', () => {
                window.app?.exportDocument('csv');
            });
            
            // File import handlers
            fileDropzone.addEventListener('dragover', (e) => {
                e.preventDefault();
                fileDropzone.classList.add('border-primary');
            });
            
            fileDropzone.addEventListener('dragleave', () => {
                fileDropzone.classList.remove('border-primary');
            });
            
            fileDropzone.addEventListener('drop', (e) => {
                e.preventDefault();
                fileDropzone.classList.remove('border-primary');
                
                if (e.dataTransfer.files.length > 0) {
                    const file = e.dataTransfer.files[0];
                    if (file.name.endsWith('.json')) {
                        handleFileImport(file);
                    } else {
                        Utils.showAlert("Please upload a valid JSON file", "danger");
                    }
                }
            });
            
            fileDropzone.addEventListener('click', () => {
                fileInput.click();
            });
            
            fileInput.addEventListener('change', () => {
                if (fileInput.files.length > 0) {
                    const file = fileInput.files[0];
                    if (file.name.endsWith('.json')) {
                        handleFileImport(file);
                    } else {
                        Utils.showAlert("Please upload a valid JSON file", "danger");
                    }
                }
            });
            
            // Button handlers
            createNewBtn.addEventListener('click', () => {
                initializeApp({ title: "New Document", items: [] });
            });
            
            addTopItemBtn.addEventListener('click', () => {
                if (window.addTopLevelItem) {
                    window.addTopLevelItem();
                }
            });
            
            importBtn.addEventListener('click', () => {
                fileInput.click();
            });
            
            document.getElementById('import-json-btn').addEventListener('click', () => {
                fileInput.click();
            });
            
            clearBtn.addEventListener('click', () => {
                const confirmModal = new bootstrap.Modal(document.getElementById('clear-confirm-modal'));
                confirmModal.show();
            });
            
            chatOpenBtn.addEventListener('click', () => {
                chatbotPanel.show();
            });
            
            document.getElementById('close-info-btn').addEventListener('click', () => {
                window.app?.setIsInfoPanelOpen(false);
            });
            
            // Chat message handlers
            const sendChatMessageHandler = () => {
                const message = chatInput.value.trim();
                if (message && window.app) {
                    window.app.sendChatMessage(message);
                    chatInput.value = '';
                }
            };
            
            chatSendBtn.addEventListener('click', sendChatMessageHandler);
            
            chatInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    sendChatMessageHandler();
                }
            });
            
            // Dialog confirmation handlers
            document.getElementById('confirm-delete-btn').addEventListener('click', () => {
                const id = document.getElementById('confirm-delete-btn').dataset.itemId;
                if (id && window.app) {
                    window.app.removeItem(id);
                    bootstrap.Modal.getInstance(document.getElementById('delete-confirm-modal')).hide();
                    bootstrap.Modal.getInstance(document.getElementById('item-editor-modal')).hide();
                }
            });
            
            document.getElementById('confirm-clear-btn').addEventListener('click', () => {
                if (window.app) {
                    window.app.clearDocument();
                    bootstrap.Modal.getInstance(document.getElementById('clear-confirm-modal')).hide();
                }
            });
            
            // Item save handler
            document.getElementById('save-item-btn').addEventListener('click', handleSaveItem);
            
            // Item delete handler
            document.getElementById('delete-item-btn').addEventListener('click', () => {
                const id = document.getElementById('item-id').value;
                if (id) {
                    document.getElementById('confirm-delete-btn').dataset.itemId = id;
                    bootstrap.Modal.getInstance(document.getElementById('item-editor-modal')).hide();
                    new bootstrap.Modal(document.getElementById('delete-confirm-modal')).show();
                }
            });
            
            // File import handler
            const handleFileImport = (file) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = JSON.parse(e.target.result);
                        
                        if (!data || !data.items) {
                            throw new Error("Invalid data structure: missing items array");
                        }
                        
                        const success = initializeApp(data, file.name);
                        
                        if (!success) {
                            throw new Error("Failed to initialize app with imported data");
                        }
                        
                        setTimeout(() => {
                            const event = new Event('app-imported-data');
                            document.dispatchEvent(event);
                        }, 500);
                    } catch (error) {
                        console.error("Error importing file:", error);
                        Utils.showAlert(`Error importing file: ${error.message}`, "danger");
                    }
                };
                reader.readAsText(file);
            };
            
            // App initialization function
            window.initializeApp = initializeApp;
        };

        // Handle saving item from modal with UUID approach
        const handleSaveItem = () => {
            try {
                const titleInput = document.getElementById('item-title');
                const contentInput = document.getElementById('item-content');
                const idInput = document.getElementById('item-id');
                const parentIdInput = document.getElementById('parent-id');
                
                if (!titleInput || !titleInput.value.trim()) {
                    Utils.showAlert("Title is required", "danger");
                    return;
                }
                
                // Get tags from Tagify
                let tags = '';
                if (window.tagify) {
                    try {
                        tags = window.tagify.value.map(t => t.value).join(',');
                    } catch (e) {
                        console.log("Tagify value extraction error:", e);
                        const tagsInput = document.getElementById('item-tags');
                        tags = tagsInput ? tagsInput.value || '' : '';
                    }
                } else {
                    const tagsInput = document.getElementById('item-tags');
                    tags = tagsInput ? tagsInput.value || '' : '';
                }
                
                // Get content from SimpleMDE
                let content = '';
                if (window.simpleMDE) {
                    try {
                        content = window.simpleMDE.value();
                    } catch (e) {
                        console.log("SimpleMDE value extraction error:", e);
                        content = contentInput ? contentInput.value || '' : '';
                    }
                } else {
                    content = contentInput ? contentInput.value || '' : '';
                }
                
                // Create item data object
                const itemData = {
                    title: titleInput.value.trim(),
                    tags: tags,
                    content: content,
                    items: []
                };
                
                if (idInput && idInput.value) {
                    // Editing an existing item - maintain the same ID
                    itemData.id = idInput.value;
                    window.app.updateItem(itemData);
                    Utils.showAlert(`Item "${itemData.title}" updated successfully`, "success");
                } else {
                    // Creating a new item - generate a new UUID
                    itemData.id = Utils.generateItemId();
                    const parentId = parentIdInput.value || null;
                    window.app.addItem(itemData, parentId);
                }
                
                // Close the modal
                const modalInstance = bootstrap.Modal.getInstance(document.getElementById('item-editor-modal'));
                if (modalInstance) {
                    modalInstance.hide();
                }
            } catch (error) {
                console.error("Error saving item:", error);
                Utils.showAlert("An error occurred while saving: " + error.message, "danger");
            }
        };

        // Initialize the app with data
        const initializeApp = (data, filename = "") => {
            if (!data || !data.items) {
                console.error("Invalid data for app initialization:", data);
                Utils.showAlert("Invalid document format", "danger");
                return false;
            }
            
            if (window.app) {
                const success = window.app.importDocument(data, filename);
                
                if (success) {
                    document.getElementById('welcome-screen').classList.add('d-none');
                    document.getElementById('document-content').classList.remove('d-none');
                    setIsInitialized(true);
                    
                    setTimeout(() => {
                        window.app.updateDocumentNavigation();
                        window.app.updateTagFilters();
                    }, 200);
                    
                    return true;
                }
                
                return false;
            } else {
                window.initialData = data;
                window.initialFilename = filename;
                document.getElementById('welcome-screen').classList.add('d-none');
                document.getElementById('document-content').classList.remove('d-none');
                setIsInitialized(true);
                
                return true;
            }
        };
        
        // Cleanup event listeners
        const cleanupEventListeners = () => {
            const elements = [
                'export-json-btn', 'export-md-btn', 'export-html-btn', 'export-docx-btn', 'export-csv-btn',
                'collapse-sidebar-btn', 'expand-sidebar-btn', 'create-new-btn', 'import-btn', 'clear-btn',
                'chat-send-btn', 'add-top-item-btn', 'chat-open-btn', 'confirm-delete-btn', 'confirm-clear-btn',
                'save-item-btn', 'delete-item-btn'
            ];
            
            elements.forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.replaceWith(element.cloneNode(true));
                }
            });
        };
        
        // Setup the global app reference and add top level item function
        React.useEffect(() => {
            if (isInitialized && window.app) {
                // Define global add top level item function
                window.addTopLevelItem = () => {
                    const modalElement = document.getElementById('item-editor-modal');
                    const modal = new bootstrap.Modal(modalElement);
                    const titleInput = document.getElementById('item-title');
                    const tagsInput = document.getElementById('item-tags');
                    const contentInput = document.getElementById('item-content');
                    const idInput = document.getElementById('item-id');
                    const parentIdInput = document.getElementById('parent-id');
                    
                    titleInput.value = '';
                    tagsInput.value = '';
                    contentInput.value = '';
                    idInput.value = '';
                    parentIdInput.value = '';
                    
                    if (window.simpleMDE) {
                        window.simpleMDE.value('');
                        setTimeout(() => window.simpleMDE.codemirror.refresh(), 10);
                    } else {
                        window.simpleMDE = new SimpleMDE({ 
                            element: contentInput,
                            spellChecker: false,
                            status: false
                        });
                    }
                    
                    if (!window.tagify) {
                        window.tagify = new Tagify(tagsInput, {
                            dropdown: {
                                enabled: 1,
                                maxItems: 5
                            }
                        });
                    } else {
                        window.tagify.removeAllTags();
                    }
                    
                    document.getElementById('item-editor-title').textContent = 'Add New Item';
                    modal.show();
                };
                
                // Import initial data if available
                if (window.initialData) {
                    window.app.importDocument(window.initialData, window.initialFilename || "");
                    window.initialData = null;
                    window.initialFilename = null;
                }
            }
        }, [isInitialized]);

        // Render appropriate content based on initialization state
        if (!isInitialized) {
            return null;
        }

        if (window.app?.items?.length > 0) {
            return <Document />;
        } else {
            return (
                <div className="text-center py-5">
                    <p className="lead">No items to display. Use the "Add Item" button to create your first item.</p>
                    <button 
                        className="btn btn-primary"
                        onClick={() => {
                            if (window.addTopLevelItem) {
                                window.addTopLevelItem();
                            }
                        }}
                    >
                        <i className="bi bi-plus-circle me-2"></i> Add First Item
                    </button>
                </div>
            );
        }
    };

    /**
     * Application context wrapper
     */
    const AppWithContext = () => {
        return (
            <DataProvider>
                <DataContext.Consumer>
                    {(context) => {
                        window.app = context;
                        return <App />;
                    }}
                </DataContext.Consumer>
            </DataProvider>
        );
    };

    // Render the application
    root.render(<AppWithContext />);
    </script>
</body>
</html>
